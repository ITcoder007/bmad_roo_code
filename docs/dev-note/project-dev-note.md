# 项目开发避坑指南

## 核心问题和解决方案

### 问题1：单测质量可疑，用Mock掩盖真实问题
**具体场景**：用户质疑"你写的单元测试是否真的有效，是不是把目标方法mock后糊弄人的？"  
**问题根因**：只有Mock测试，没有真实端到端验证  
**解决方案**：立即创建真实集成测试证明功能确实work

**具体做法**：
- 写一个`RealXxxTest`类，完全不用Mock
- 用`@SpringBootTest`启动完整应用上下文
- 测试真实的业务流程，如果失败就说明Mock测试确实在"糊弄"

---

### 问题2：测试失败时盲目全量跑测试
**具体场景**：代码改动后直接`mvn test`，10分钟后发现是无关的集成测试依赖问题  
**问题根因**：没有分层测试策略，浪费时间在不相关的测试上  
**解决方案**：按测试类型分层执行，快速定位问题

**具体做法**：
- 先跑核心业务逻辑测试（纯单元测试）
- 再跑需要Spring上下文的服务测试
- 最后跑需要数据库/外部依赖的集成测试
- 哪层失败就在哪层解决问题

---

### 问题3：时间边界测试的精度问题处理不当
**具体场景**：测试`getDaysUntilExpiry()`时，有时返回30天，有时29天，导致测试不稳定  
**问题根因**：测试执行时间跨越了天的边界，或者毫秒级计算精度问题  
**错误做法**：用`isBetween(29L, 30L)`允许误差范围

**正确做法**：
- 在测试中固定时间基准点，不要用`new Date()`
- 使用确定的时间差计算，避免"现在"的不确定性
- 如果必须用当前时间，应该控制测试数据让结果确定

```java
// ❌ 不稳定的做法
Certificate cert = createCertificate(30); // 30天后过期
long days = cert.getDaysUntilExpiry(); // 可能是29或30
assertThat(days).isBetween(29L, 30L); // 这是在掩盖问题

// ✅ 正确的做法  
Date fixedNow = new Date();
Date expiry = new Date(fixedNow.getTime() + 30 * 24 * 60 * 60 * 1000L);
Certificate cert = Certificate.builder().expiryDate(expiry).build();
long days = cert.getDaysUntilExpiry(fixedNow); // 传入固定基准时间
assertThat(days).isEqualTo(30L); // 结果应该是确定的
```

---

### 问题4：缺乏TDD开发习惯导致返工
**具体场景**：写完功能发现测试很难写，或者测试通过了但功能不对  
**问题根因**：代码优先，测试补充的开发方式导致设计不合理  
**解决方案**：严格按照TDD红绿重构循环开发

**TDD标准流程**：
1. **红色阶段**：先写一个失败的测试，明确需求
2. **绿色阶段**：写最少的代码让测试通过
3. **重构阶段**：在测试保护下改进代码结构
4. **重复循环**：每个新功能都走这个流程

**具体实施**：
- 每写一个新方法前，先写测试用例
- 测试用例要体现真实的业务场景
- 先让测试失败，确保测试真的在验证功能
- 实现功能时只写刚好通过测试的代码
- 功能完成后重构，但保证所有测试依然通过

---

## 核心原则

**测试质量原则**：Mock测试验证接口，真实测试验证功能，两者缺一不可  
**开发效率原则**：分层测试快速定位问题，不要一上来就跑全量  
**时间处理原则**：测试中的时间计算必须是确定的，不能依赖执行时的随机性  
**TDD习惯原则**：先写测试明确需求，再写实现，最后重构优化

---

*最后更新：2025-08-15 | 来源：Story 1.4 开发复盘*