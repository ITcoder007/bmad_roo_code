# Story 2.4: 短信通知服务（日志实现）

## Status
Approved

## Story
**As a** 后端开发人员,
**I want** 实现短信通知服务的日志记录,
**so that** 系统能够记录短信发送的预警信息.

## Acceptance Criteria
1. 实现短信预警信息的日志记录功能
2. 记录预警证书的基本信息，包括证书名称、域名和到期日期
3. 记录预警的时间点和预警类型（如30天、15天、7天、1天）
4. 添加日志格式的基本配置功能
5. 编写日志记录的单元测试
6. 验证日志记录的基本功能

## Tasks / Subtasks
- [ ] Task 1: 创建短信服务接口和实现（AC: 1）
  - [ ] Subtask 1.1: 创建 `service/SmsService.java` 接口，定义短信发送契约
  - [ ] Subtask 1.2: 创建 `service/impl/SmsServiceImpl.java` 实现类（用于生产环境）
  - [ ] Subtask 1.3: 创建 `infrastructure/external/sms/LogSmsServiceImpl.java` 日志实现类（MVP阶段）
  - [ ] Subtask 1.4: 配置 Spring 依赖注入，默认使用日志实现

- [ ] Task 2: 实现短信预警信息记录（AC: 2, 3）
  - [ ] Subtask 2.1: 在 `LogSmsServiceImpl` 中实现 `sendExpiryAlertSms()` 方法
  - [ ] Subtask 2.2: 设计短信预警日志格式，包含证书名称、域名、到期日期、预警类型
  - [ ] Subtask 2.3: 集成 `MonitoringLogService` 记录短信预警到数据库
  - [ ] Subtask 2.4: 添加短信发送结果的结构化日志记录

- [ ] Task 3: 创建短信配置服务（AC: 4）
  - [ ] Subtask 3.1: 创建 `config/SmsConfig.java` 配置类
  - [ ] Subtask 3.2: 添加短信相关配置项到 `application.yml`
  - [ ] Subtask 3.3: 实现短信模板配置和格式化功能
  - [ ] Subtask 3.4: 实现短信发送策略配置（实际发送 vs 日志记录）

- [ ] Task 4: 集成预警规则引擎（AC: 3）
  - [ ] Subtask 4.1: 修改 `AlertRuleEngineImpl`，集成短信服务
  - [ ] Subtask 4.2: 在预警触发时调用短信服务
  - [ ] Subtask 4.3: 根据预警规则确定短信发送时机（30天、15天、7天、1天）
  - [ ] Subtask 4.4: 添加短信预警的去重逻辑，避免重复发送

- [ ] Task 5: 编写单元测试（AC: 5）
  - [ ] Subtask 5.1: 创建 `test/service/SmsServiceTest.java` 测试类
  - [ ] Subtask 5.2: 编写 `testSendExpiryAlertSms_LogMode()` 测试方法
  - [ ] Subtask 5.3: 编写 `testSmsLogFormat()` 测试短信日志格式
  - [ ] Subtask 5.4: 编写 `testSmsConfigurationLoading()` 测试配置加载
  - [ ] Subtask 5.5: 创建 `test/infrastructure/external/sms/LogSmsServiceTest.java` 测试日志短信服务

- [ ] Task 6: 集成测试和功能验证（AC: 6）
  - [ ] Subtask 6.1: 创建集成测试，验证短信服务与预警引擎的集成
  - [ ] Subtask 6.2: 创建测试数据，模拟不同预警场景的短信发送
  - [ ] Subtask 6.3: 验证短信日志记录的完整性和格式
  - [ ] Subtask 6.4: 验证短信预警去重逻辑的正确性
  - [ ] Subtask 6.5: 验证配置切换功能（日志模式 vs 实际发送模式）

## Dev Notes

### 前一个故事的关键信息
基于 [Source: docs/stories/2.3.story.md#Dev Agent Record]：
- 邮件服务已完成，采用日志实现方案，建立了通用的通知服务架构
- 创建了 EmailResult 数据结构，可作为 SmsResult 的设计参考
- 实现了 EmailLogFormatter 分离格式化逻辑，可复用相同模式
- 错误处理机制已标准化，短信服务应采用相同的错误处理策略
- 预警规则引擎已完成并集成到监控服务中

### 技术栈配置
根据 [Source: architecture/3.tech-stack.md]：

**后端技术栈（必须使用）：**
- Java 8 - 后端开发语言
- Spring Boot 2.7.x - 后端框架
- MyBatis Plus 3.5.x - ORM框架
- MySQL 8.0 - 数据库
- Logback 1.3.x - 日志框架
- JUnit 5.x + Mockito 4.x - 测试框架

### 项目结构
根据 [Source: architecture/12.unified-project-structure.md]：

**短信服务相关文件位置：**
```
backend/src/main/java/com/example/certificate/
├── service/
│   ├── SmsService.java                      # 短信服务接口
│   └── impl/
│       └── SmsServiceImpl.java              # 短信服务实现（生产环境）
├── infrastructure/
│   └── external/
│       └── sms/
│           ├── LogSmsServiceImpl.java       # 日志短信服务实现（MVP阶段）
│           └── SmsTemplate.java             # 短信模板类
├── config/
│   └── SmsConfig.java                       # 短信配置类
└── common/
    └── constant/
        └── SmsConstants.java                # 短信相关常量
```

### 短信服务设计
根据 [Source: architecture/11.backend-architecture.md#设计模式]：

**短信服务接口：**
```java
public interface SmsService {
    /**
     * 发送证书过期预警短信
     * @param certificate 证书信息
     * @param daysUntilExpiry 距离过期的天数
     * @param recipientPhone 收件人手机号
     * @return 短信发送结果
     */
    SmsResult sendExpiryAlertSms(Certificate certificate, int daysUntilExpiry, String recipientPhone);
    
    /**
     * 发送每日证书状态摘要短信
     * @param expiringSoonCertificates 即将过期的证书列表
     * @param expiredCertificates 已过期的证书列表
     * @param recipientPhone 收件人手机号
     * @return 短信发送结果
     */
    SmsResult sendDailySummary(List<Certificate> expiringSoonCertificates, 
                              List<Certificate> expiredCertificates, 
                              String recipientPhone);
}
```

**日志短信服务实现：**
```java
@Service("logSmsService")
@Primary
public class LogSmsServiceImpl implements SmsService {
    private static final Logger log = LoggerFactory.getLogger(LogSmsServiceImpl.class);
    
    private final MonitoringLogService monitoringLogService;
    private final SmsLogFormatter smsLogFormatter;
    
    @Override
    public SmsResult sendExpiryAlertSms(Certificate certificate, int daysUntilExpiry, String recipientPhone) {
        // 使用格式化器生成日志消息
        String logMessage = smsLogFormatter.formatExpiryAlert(
            recipientPhone, certificate, daysUntilExpiry);
        
        log.info(logMessage);
        
        // 记录监控日志到数据库
        monitoringLogService.logSmsAlert(certificate, daysUntilExpiry, recipientPhone);
        
        return SmsResult.success()
            .message("SMS alert logged (MVP mode)")
            .recipient(recipientPhone)
            .sentAt(LocalDateTime.now())
            .build();
    }
    
    @Override
    public SmsResult sendDailySummary(List<Certificate> expiringSoonCertificates, 
                                     List<Certificate> expiredCertificates, 
                                     String recipientPhone) {
        String summaryMessage = smsLogFormatter.formatDailySummary(
            recipientPhone, expiringSoonCertificates, expiredCertificates);
        
        log.info(summaryMessage);
        
        // 记录每个证书的详细信息
        smsLogFormatter.logCertificateDetails(expiringSoonCertificates, "即将过期");
        smsLogFormatter.logCertificateDetails(expiredCertificates, "已过期");
        
        // 记录监控日志
        monitoringLogService.logSmsDailySummary(expiringSoonCertificates, expiredCertificates, recipientPhone);
        
        return SmsResult.success()
            .message("Daily summary logged (MVP mode)")
            .recipient(recipientPhone)
            .sentAt(LocalDateTime.now())
            .build();
    }
}
```

### 短信结果模型
根据 [Source: architecture/4.data-models.md] 和 Story 2.3 的经验：

**短信发送结果（参考 EmailResult 设计）：**
```java
public final class SmsResult {
    private final boolean success;
    private final String message;
    private final String recipient;
    private final LocalDateTime sentAt;
    private final String errorCode;
    private final String errorMessage;
    
    private SmsResult(Builder builder) {
        this.success = builder.success;
        this.message = builder.message;
        this.recipient = builder.recipient;
        this.sentAt = builder.sentAt;
        this.errorCode = builder.errorCode;
        this.errorMessage = builder.errorMessage;
    }
    
    // 静态工厂方法
    public static Builder success() {
        return new Builder().success(true);
    }
    
    public static Builder failure() {
        return new Builder().success(false);
    }
    
    // Builder 模式
    public static class Builder {
        private boolean success;
        private String message;
        private String recipient;
        private LocalDateTime sentAt;
        private String errorCode;
        private String errorMessage;
        
        public Builder success(boolean success) {
            this.success = success;
            return this;
        }
        
        public Builder message(String message) {
            this.message = message;
            return this;
        }
        
        public Builder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }
        
        public Builder sentAt(LocalDateTime sentAt) {
            this.sentAt = sentAt;
            return this;
        }
        
        public Builder errorCode(String errorCode) {
            this.errorCode = errorCode;
            return this;
        }
        
        public Builder errorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
            return this;
        }
        
        public SmsResult build() {
            return new SmsResult(this);
        }
    }
    
    // getters, equals, hashCode, toString...
}
```

### 短信日志格式化器
参考 Story 2.3 的 EmailLogFormatter 设计：

**短信日志格式化器：**
```java
@Component
public class SmsLogFormatter {
    private static final Logger log = LoggerFactory.getLogger(SmsLogFormatter.class);
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    
    public String formatExpiryAlert(String recipientPhone, Certificate certificate, int daysUntilExpiry) {
        return String.format(
            "短信预警 - 收件人: %s, 证书: %s, 域名: %s, 到期日期: %s, 剩余天数: %d天", 
            recipientPhone, certificate.getName(), certificate.getDomain(), 
            certificate.getExpiryDate().format(DATE_FORMATTER), daysUntilExpiry);
    }
    
    public String formatDailySummary(String recipientPhone, 
                                   List<Certificate> expiringSoonCertificates, 
                                   List<Certificate> expiredCertificates) {
        return String.format(
            "每日摘要短信 - 收件人: %s, 即将过期证书: %d个, 已过期证书: %d个",
            recipientPhone, expiringSoonCertificates.size(), expiredCertificates.size());
    }
    
    public void logCertificateDetails(List<Certificate> certificates, String status) {
        certificates.forEach(cert -> {
            log.info("{} - 证书: {}, 域名: {}, 到期日期: {}", 
                    status, cert.getName(), cert.getDomain(), 
                    cert.getExpiryDate().format(DATE_FORMATTER));
        });
    }
}
```

### 集成到预警系统
根据 [Source: architecture/8.core-workflows.md#证书预警工作流] 和 Story 2.3 的实现：

**预警服务集成（扩展现有 AlertServiceImpl）：**
```java
@Service
public class AlertServiceImpl implements AlertService {
    private final EmailService emailService;
    private final SmsService smsService; // 新增短信服务
    private final AlertRuleEngine alertRuleEngine;
    
    @Value("${alert.email.default-recipient}")
    private String defaultEmailRecipient;
    
    @Value("${alert.sms.default-recipient}")
    private String defaultSmsRecipient;
    
    public void sendExpiryAlert(Certificate certificate, int daysUntilExpiry) {
        List<AlertRule> triggeredRules = alertRuleEngine.getTriggeredRules(certificate);
        
        for (AlertRule rule : triggeredRules) {
            List<String> channels = rule.getAlertChannels();
            
            if (channels.contains("EMAIL")) {
                EmailResult result = emailService.sendExpiryAlertEmail(
                    certificate, daysUntilExpiry, defaultEmailRecipient);
                
                if (!result.isSuccess()) {
                    log.error("邮件预警发送失败 - 证书: {}, 错误: {}", 
                             certificate.getName(), result.getErrorMessage());
                }
            }
            
            if (channels.contains("SMS")) {
                SmsResult result = smsService.sendExpiryAlertSms(
                    certificate, daysUntilExpiry, defaultSmsRecipient);
                
                if (!result.isSuccess()) {
                    log.error("短信预警发送失败 - 证书: {}, 错误: {}", 
                             certificate.getName(), result.getErrorMessage());
                }
            }
        }
    }
}
```

### 配置管理
根据 [Source: architecture/11.backend-architecture.md#配置类]：

**短信配置：**
```yaml
# application.yml
alert:
  sms:
    enabled: true
    mode: log # log | real
    default-recipient: "13800138000"
    provider:
      name: aliyun # aliyun | tencent | custom
      access-key: ${SMS_ACCESS_KEY:}
      secret-key: ${SMS_SECRET_KEY:}
      endpoint: ${SMS_ENDPOINT:}
    templates:
      expiry-alert:
        template-code: "SMS_001"
        signature: "证书管理系统"
        content: "【证书管理】证书{certificateName}将在{daysUntilExpiry}天后过期，请及时处理。"
      daily-summary:
        template-code: "SMS_002"
        signature: "证书管理系统"
        content: "【证书管理】今日摘要：即将过期{expiringSoonCount}个，已过期{expiredCount}个证书。"
```

**配置类：**
```java
@Configuration
@ConfigurationProperties(prefix = "alert.sms")
@Data
public class SmsConfig {
    private boolean enabled = true;
    private String mode = "log"; // log | real
    private String defaultRecipient;
    private ProviderConfig provider = new ProviderConfig();
    private Map<String, SmsTemplateConfig> templates = new HashMap<>();
    
    @Data
    public static class ProviderConfig {
        private String name = "aliyun";
        private String accessKey;
        private String secretKey;
        private String endpoint;
    }
    
    @Data
    public static class SmsTemplateConfig {
        private String templateCode;
        private String signature;
        private String content;
    }
}
```

### 监控日志扩展
根据 [Source: architecture/4.data-models.md]：

**监控日志服务扩展：**
```java
public interface MonitoringLogService {
    // 现有方法...
    
    /**
     * 记录短信预警日志
     */
    void logSmsAlert(Certificate certificate, int daysUntilExpiry, String recipient);
    
    /**
     * 记录短信每日摘要日志
     */
    void logSmsDailySummary(List<Certificate> expiringSoonCertificates, 
                           List<Certificate> expiredCertificates, 
                           String recipient);
}
```

### 错误处理策略
根据 [Source: architecture/11.backend-architecture.md#异常处理] 和 Story 2.3 的模式：

**短信服务异常处理：**
```java
public class SmsServiceException extends RuntimeException {
    private String recipient;
    private String certificateId;
    
    public SmsServiceException(String message, String recipient, String certificateId) {
        super(message);
        this.recipient = recipient;
        this.certificateId = certificateId;
    }
}

// 在短信服务中的异常处理（统一错误处理模板）
private <T> SmsResult executeWithErrorHandling(String operation, 
                                              Supplier<SmsResult> businessOperation) {
    try {
        return businessOperation.get();
    } catch (Exception e) {
        log.error("短信服务操作失败 - 操作: {}, 错误: {}", operation, e.getMessage());
        
        return SmsResult.failure()
            .errorMessage(e.getMessage())
            .errorCode("SMS_OPERATION_FAILED")
            .build();
    }
}
```

### 编码规范
根据 [Source: architecture/17.coding-standards.md]：

**命名规范：**
- 类名: PascalCase (如 `SmsService`)
- 方法/变量: camelCase (如 `sendExpiryAlertSms`)
- 常量: UPPER_SNAKE_CASE (如 `DEFAULT_SMS_TEMPLATE`)
- 配置属性: kebab-case (如 `alert.sms.default-recipient`)

**关键规则：**
- 使用构造函数注入依赖
- 接口与实现分离
- 每个方法都要有适当的日志记录
- 不能在日志或错误信息中暴露敏感信息（如手机号码需要脱敏）

## Testing
根据 [Source: architecture/16.testing-strategy.md#后端测试]：

**测试标准：**
- 使用 JUnit 5 作为测试框架
- 使用 Mockito 进行依赖模拟
- 测试文件位置：`backend/src/test/java/com/example/certificate/`
- 测试命名：`XxxTest.java`
- 测试方法命名：`testMethodName_scenario_expectedResult()`
- 覆盖率目标：核心业务逻辑 80%+

**测试示例：**
```java
@ExtendWith(MockitoExtension.class)
class LogSmsServiceTest {
    @Mock
    private MonitoringLogService monitoringLogService;
    
    @Mock
    private SmsLogFormatter smsLogFormatter;
    
    @InjectMocks
    private LogSmsServiceImpl logSmsService;
    
    @Test
    void testSendExpiryAlertSms_LogMode_shouldLogAndReturnSuccess() {
        // Given
        Certificate certificate = createCertificate("测试证书", "test.example.com");
        int daysUntilExpiry = 15;
        String recipient = "13800138000";
        
        when(smsLogFormatter.formatExpiryAlert(recipient, certificate, daysUntilExpiry))
            .thenReturn("短信预警 - 收件人: 138****8000, 证书: 测试证书, 域名: test.example.com, 到期日期: 2024-12-31, 剩余天数: 15天");
        
        // When
        SmsResult result = logSmsService.sendExpiryAlertSms(certificate, daysUntilExpiry, recipient);
        
        // Then
        assertTrue(result.isSuccess());
        assertEquals("SMS alert logged (MVP mode)", result.getMessage());
        assertEquals(recipient, result.getRecipient());
        assertNotNull(result.getSentAt());
        
        verify(monitoringLogService).logSmsAlert(certificate, daysUntilExpiry, recipient);
        verify(smsLogFormatter).formatExpiryAlert(recipient, certificate, daysUntilExpiry);
    }
    
    @Test
    void testSendDailySummary_LogMode_shouldLogSummaryAndDetails() {
        // Given
        List<Certificate> expiringSoon = Arrays.asList(
            createCertificate("证书1", "site1.example.com"),
            createCertificate("证书2", "site2.example.com")
        );
        List<Certificate> expired = Arrays.asList(
            createCertificate("过期证书", "old.example.com")
        );
        String recipient = "13800138000";
        
        when(smsLogFormatter.formatDailySummary(recipient, expiringSoon, expired))
            .thenReturn("每日摘要短信 - 收件人: 138****8000, 即将过期证书: 2个, 已过期证书: 1个");
        
        // When
        SmsResult result = logSmsService.sendDailySummary(expiringSoon, expired, recipient);
        
        // Then
        assertTrue(result.isSuccess());
        assertEquals("Daily summary logged (MVP mode)", result.getMessage());
        assertEquals(recipient, result.getRecipient());
        
        verify(monitoringLogService).logSmsDailySummary(expiringSoon, expired, recipient);
        verify(smsLogFormatter).formatDailySummary(recipient, expiringSoon, expired);
        verify(smsLogFormatter).logCertificateDetails(expiringSoon, "即将过期");
        verify(smsLogFormatter).logCertificateDetails(expired, "已过期");
    }
}
```

**运行测试命令：**
```bash
cd backend
mvn test -Dtest=LogSmsServiceTest
mvn test -Dtest=SmsServiceTest
mvn test # 运行所有测试
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-17 | 1.0 | 初始故事创建 | Bob (Scrum Master) |