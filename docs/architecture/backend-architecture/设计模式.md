# 设计模式

## 1. 依赖注入模式

- **描述**：使用Spring的依赖注入机制，通过构造函数注入依赖
- **优点**：降低组件间耦合，提高可测试性和可维护性
- **实现示例**：
  ```java
  @Service
  public class CertificateServiceImpl implements CertificateService {
      private final CertificateRepository certificateRepository;
      private final MonitoringLogService monitoringLogService;
      
      @Autowired
      public CertificateServiceImpl(CertificateRepository certificateRepository, 
                                  MonitoringLogService monitoringLogService) {
          this.certificateRepository = certificateRepository;
          this.monitoringLogService = monitoringLogService;
      }
      
      // 其他方法...
  }
  ```

## 2. 仓库模式

- **描述**：在领域层定义仓库接口，在基础设施层实现
- **优点**：分离领域逻辑和数据访问逻辑，提高可测试性
- **实现示例**：
  ```java
  // 领域层 - 仓库接口
  public interface CertificateRepository {
      Optional<Certificate> findById(Long id);
      List<Certificate> findAll();
      Certificate save(Certificate certificate);
      void deleteById(Long id);
      List<Certificate> findByStatus(CertificateStatus status);
      List<Certificate> findByExpiryDateBefore(Date date);
  }
  
  // 基础设施层 - 仓库实现
  @Repository
  public class CertificateRepositoryImpl implements CertificateRepository {
      private final CertificateMyBatisRepository myBatisRepository;
      
      @Autowired
      public CertificateRepositoryImpl(CertificateMyBatisRepository myBatisRepository) {
          this.myBatisRepository = myBatisRepository;
      }
      
      @Override
      public Optional<Certificate> findById(Long id) {
          return myBatisRepository.findById(id)
              .map(entity -> convertToDomain(entity));
      }
      
      // 其他方法实现...
      
      private Certificate convertToDomain(CertificateEntity entity) {
          // 转换逻辑...
      }
  }
  ```

## 3. 策略模式

- **描述**：为不同的算法或行为定义统一的接口，实现可互换的算法族
- **优点**：提高代码的灵活性和可扩展性
- **实现示例**：
  ```java
  // 策略接口
  public interface EmailService {
      EmailResult sendExpiryAlertEmail(Certificate certificate, int daysUntilExpiry, String recipientEmail);
  }
  
  // 具体策略实现 - 实际邮件服务
  @Service("realEmailService")
  public class EmailServiceImpl implements EmailService {
      // 实际邮件发送逻辑...
  }
  
  // 具体策略实现 - 日志邮件服务
  @Service("logEmailService")
  @Primary
  public class LogEmailServiceImpl implements EmailService {
      @Override
      public EmailResult sendExpiryAlertEmail(Certificate certificate, int daysUntilExpiry, String recipientEmail) {
          // 记录日志而不实际发送邮件
          log.info("Email alert would be sent to {} for certificate {} expiring in {} days", 
                  recipientEmail, certificate.getName(), daysUntilExpiry);
          
          EmailResult result = new EmailResult();
          result.setSuccess(true);
          result.setMessage("Email alert logged (MVP mode)");
          return result;
      }
  }
  
  // 策略使用
  @Service
  public class AlertServiceImpl implements AlertService {
      private final EmailService emailService;
      
      @Autowired
      public AlertServiceImpl(@Qualifier("logEmailService") EmailService emailService) {
          this.emailService = emailService;
      }
      
      // 其他方法...
  }
  ```

## 4. 工厂模式

- **描述**：提供一个创建对象的接口，让子类决定实例化哪一个类
- **优点**：封装对象的创建逻辑，提高代码的灵活性和可维护性
- **实现示例**：
  ```java
  // 工厂接口
  public interface CertificateValidationServiceFactory {
      CertificateValidationService createValidationService(String provider);
  }
  
  // 工厂实现
  @Service
  public class CertificateValidationServiceFactoryImpl implements CertificateValidationServiceFactory {
      private final Map<String, CertificateValidationService> serviceMap;
      
      @Autowired
      public CertificateValidationServiceFactoryImpl(
          Map<String, CertificateValidationService> serviceMap) {
          this.serviceMap = serviceMap;
      }
      
      @Override
      public CertificateValidationService createValidationService(String provider) {
          CertificateValidationService service = serviceMap.get(provider);
          if (service == null) {
              throw new IllegalArgumentException("Unsupported validation provider: " + provider);
          }
          return service;
      }
  }
  
  // 工厂使用
  @Service
  public class MonitoringServiceImpl implements MonitoringService {
      private final CertificateValidationServiceFactory validationServiceFactory;
      
      @Autowired
      public MonitoringServiceImpl(CertificateValidationServiceFactory validationServiceFactory) {
          this.validationServiceFactory = validationServiceFactory;
      }
      
      public ValidationResult validateCertificate(Certificate certificate) {
          String provider = "builtin"; // 可以从配置中读取
          CertificateValidationService validationService = validationServiceFactory.createValidationService(provider);
          return validationService.validateCertificate(certificate);
      }
  }
  ```

## 5. 观察者模式

- **描述**：定义对象间的一种一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知
- **优点**：实现对象间的松耦合，支持动态添加和删除观察者
- **实现示例**：
  ```java
  // 事件发布者
  @Service
  public class CertificateEventPublisher {
      private final ApplicationEventPublisher eventPublisher;
      
      @Autowired
      public CertificateEventPublisher(ApplicationEventPublisher eventPublisher) {
          this.eventPublisher = eventPublisher;
      }
      
      public void publishCertificateCreatedEvent(Certificate certificate) {
          eventPublisher.publishEvent(new CertificateCreatedEvent(certificate));
      }
      
      public void publishCertificateUpdatedEvent(Certificate certificate) {
          eventPublisher.publishEvent(new CertificateUpdatedEvent(certificate));
      }
      
      public void publishCertificateDeletedEvent(Certificate certificate) {
          eventPublisher.publishEvent(new CertificateDeletedEvent(certificate));
      }
      
      public void publishCertificateStatusChangedEvent(Certificate certificate, CertificateStatus oldStatus) {
          eventPublisher.publishEvent(new CertificateStatusChangedEvent(certificate, oldStatus));
      }
  }
  
  // 事件监听者
  @Service
  public class CertificateEventListener {
      private final MonitoringLogService monitoringLogService;
      
      @Autowired
      public CertificateEventListener(MonitoringLogService monitoringLogService) {
          this.monitoringLogService = monitoringLogService;
      }
      
      @EventListener
      public void handleCertificateCreatedEvent(CertificateCreatedEvent event) {
          Certificate certificate = event.getCertificate();
          monitoringLogService.logCertificateCreated(certificate);
      }
      
      @EventListener
      public void handleCertificateUpdatedEvent(CertificateUpdatedEvent event) {
          Certificate certificate = event.getCertificate();
          monitoringLogService.logCertificateUpdated(certificate);
      }
      
      @EventListener
      public void handleCertificateDeletedEvent(CertificateDeletedEvent event) {
          Certificate certificate = event.getCertificate();
          monitoringLogService.logCertificateDeleted(certificate);
      }
      
      @EventListener
      public void handleCertificateStatusChangedEvent(CertificateStatusChangedEvent event) {
          Certificate certificate = event.getCertificate();
          CertificateStatus oldStatus = event.getOldStatus();
          monitoringLogService.logCertificateStatusChanged(certificate, oldStatus);
      }
  }
  ```
