# 部署架构

## 概述

证书生命周期管理系统的部署架构定义了从开发到生产的完整部署流程。本节详细说明了部署策略、CI/CD 流程、环境配置以及各个环境的部署方式，确保系统能够稳定、高效地运行在不同环境中。

## 部署策略

### 前端部署

#### 平台选择

前端应用基于 Vue.js 构建，可以部署在多种平台上：

1. **静态托管服务**（推荐）
   - **Netlify**: 提供自动部署、CDN 分发和表单处理功能
   - **Vercel**: 专为前端应用优化的部署平台，支持 Serverless 函数
   - **GitHub Pages**: 适合简单的静态站点，免费且易于使用

2. **云存储服务**
   - **AWS S3 + CloudFront**: 高可用的静态资源存储和 CDN 分发
   - **阿里云 OSS + CDN**: 国内访问速度快，适合国内用户
   - **Azure Blob Storage**: 微软云提供的存储服务

3. **传统服务器**
   - **Nginx**: 高性能的 Web 服务器，适合静态资源托管
   - **Apache**: 功能丰富的 Web 服务器，支持多种模块

#### 构建配置

前端使用 Vite 作为构建工具，`vite.config.js` 配置示例：

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    },
    rollupOptions: {
      output: {
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: '[ext]/[name]-[hash].[ext]',
        manualChunks: {
          vue: ['vue', 'vue-router', 'pinia'],
          elementPlus: ['element-plus'],
          echarts: ['echarts']
        }
      }
    }
  },
  server: {
    port: 3000,
    open: true,
    cors: true,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '/api')
      }
    }
  }
})
```

#### 构建命令

```bash
# 构建生产版本
cd frontend
npm run build

# 构建结果将输出到 frontend/dist 目录
```

#### 输出目录

构建完成后，前端应用的静态资源将输出到 `frontend/dist` 目录：

```
frontend/dist/
├── assets/                    # 静态资源
│   ├── css/                  # CSS 文件
│   │   ├── index-xxxxxx.css
│   │   └── index-xxxxxx.css.map
│   ├── js/                   # JavaScript 文件
│   │   ├── index-xxxxxx.js
│   │   ├── index-xxxxxx.js.map
│   │   ├── vue-xxxxxx.js
│   │   └── vue-xxxxxx.js.map
│   └── images/               # 图片资源
│       └── logo.png
├── favicon.ico               # 网站图标
└── index.html                # HTML 入口文件
```

#### CDN/Edge 配置

为了提高前端应用的加载速度和可用性，建议使用 CDN 分发静态资源：

1. **资源上传**
   - 将 `frontend/dist/assets` 目录下的所有文件上传到 CDN
   - 确保文件名包含哈希值，以便缓存管理

2. **CDN 配置**
   - 设置适当的缓存策略（如 CSS/JS 文件缓存 1 年）
   - 配置 gzip 压缩减少传输大小
   - 启用 HTTP/2 提高并发性能

3. **域名配置**
   - 为 CDN 配置单独的域名（如 `assets.example.com`）
   - 配置 HTTPS 证书确保安全传输

### 后端部署

#### 平台选择

后端应用基于 Spring Boot 构建，可以部署在多种平台上：

1. **云平台**（推荐）
   - **AWS Elastic Beanstalk**: 简化的应用部署平台，支持自动扩展
   - **阿里云 ECS**: 弹性计算服务，提供灵活的配置选项
   - **Heroku**: 平台即服务，简化部署流程
   - **Google Cloud App Engine**: 全托管的应用平台

2. **容器平台**
   - **Docker**: 使用容器化部署，提高环境一致性
   - **Kubernetes**: 容器编排平台，支持自动扩展和负载均衡
   - **Docker Compose**: 本地开发和测试环境

3. **传统服务器**
   - **物理服务器**: 完全控制硬件资源，适合有特殊需求的应用
   - **虚拟机**: 提供资源隔离，适合中小型应用

#### 构建配置

后端使用 Maven 作为构建工具，`pom.xml` 配置示例：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>certificate-lifecycle-management-backend</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <spring-boot.version>2.7.10</spring-boot.version>
    </properties>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.10</version>
        <relativePath/>
    </parent>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- MyBatis Plus -->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.3.1</version>
        </dependency>
        
        <!-- MySQL -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

#### 构建命令

```bash
# 构建生产版本
cd backend
mvn clean package -DskipTests

# 构建结果将输出到 backend/target 目录
```

#### 输出目录

构建完成后，后端应用的可执行 JAR 文件将输出到 `backend/target` 目录：

```
backend/target/
├── certificate-lifecycle-management-backend-1.0.0.jar  # 可执行 JAR 文件
├── certificate-lifecycle-management-backend-1.0.0.jar.original  # 原始 JAR 文件
├── classes/                    # 编译后的类文件
├── generated-sources/          # 生成的源代码
├── maven-archiver/              # Maven 打包相关文件
└── maven-status/               # Maven 状态文件
```

#### 容器化部署

为了提高部署的一致性和可移植性，建议使用 Docker 容器化部署后端应用：

1. **Dockerfile**

```dockerfile
# 使用官方 OpenJDK 8 镜像作为基础镜像
FROM openjdk:8-jre-alpine

# 设置工作目录
WORKDIR /app

# 复制构建好的 JAR 文件到容器中
COPY target/certificate-lifecycle-management-backend-1.0.0.jar app.jar

# 设置 JVM 参数
ENV JAVA_OPTS="-Xmx512m -Xms256m"

# 暴露端口
EXPOSE 8080

# 设置健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

2. **构建 Docker 镜像**

```bash
# 在项目根目录执行
docker build -f infrastructure/docker/api/Dockerfile -t clm-api:latest .
```

3. **运行 Docker 容器**

```bash
# 运行容器
docker run -d \
  --name clm-api \
  -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -e DB_HOST=database \
  -e DB_PORT=3306 \
  -e DB_NAME=certificate_management \
  -e DB_USER=certificate_user \
  -e DB_PASSWORD=certificate_password \
  -e JWT_SECRET=your-jwt-secret-key \
  --link mysql-database:database \
  clm-api:latest
```

## CI/CD 流程

### Git 工作流

项目使用 Git Flow 分支策略进行版本控制：

- `main`: 主分支，用于生产环境
- `develop`: 开发分支，用于集成开发功能
- `feature/*`: 功能分支，用于开发新功能
- `hotfix/*`: 修复分支，用于紧急修复生产问题
- `release/*`: 发布分支，用于准备新版本发布

### CI/CD 配置

#### GitHub Actions 配置

项目使用 GitHub Actions 进行持续集成和持续部署，配置文件位于 `.github/workflows/` 目录中：

1. **CI 工作流** (`.github/workflows/ci.yml`)

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: rootpassword
          MYSQL_DATABASE: certificate_management_test
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install backend dependencies
      run: |
        cd backend
        mvn install -DskipTests
    
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Run backend tests
      run: |
        cd backend
        mvn test
    
    - name: Run frontend tests
      run: |
        cd frontend
        npm run test
    
    - name: Build frontend
      run: |
        cd frontend
        npm run build
    
    - name: Build backend
      run: |
        cd backend
        mvn clean package -DskipTests
    
    - name: Upload backend build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: backend-jar
        path: backend/target/*.jar
    
    - name: Upload frontend build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: frontend-dist
        path: frontend/dist/
```

2. **CD 工作流** (`.github/workflows/deploy.yml`)

```yaml
name: CD

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Download backend build artifacts
      uses: actions/download-artifact@v3
      with:
        name: backend-jar
        path: backend/target/
    
    - name: Download frontend build artifacts
      uses: actions/download-artifact@v3
      with:
        name: frontend-dist
        path: frontend/dist/
    
    - name: Deploy to staging
      run: |
        # 部署脚本示例，实际部署方式根据目标平台调整
        echo "Deploying to staging environment..."
        # 这里可以添加具体的部署命令，如：
        # 1. 上传 JAR 文件到服务器
        # 2. 上传前端静态文件到 CDN 或静态托管服务
        # 3. 重启后端服务
        # 4. 更新前端版本
  
  deploy-production:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: deploy-staging
    environment: production
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Download backend build artifacts
      uses: actions/download-artifact@v3
      with:
        name: backend-jar
        path: backend/target/
    
    - name: Download frontend build artifacts
      uses: actions/download-artifact@v3
      with:
        name: frontend-dist
        path: frontend/dist/
    
    - name: Deploy to production
      run: |
        # 部署脚本示例，实际部署方式根据目标平台调整
        echo "Deploying to production environment..."
        # 这里可以添加具体的部署命令，如：
        # 1. 上传 JAR 文件到服务器
        # 2. 上传前端静态文件到 CDN 或静态托管服务
        # 3. 重启后端服务
        # 4. 更新前端版本
        # 5. 运行数据库迁移
```

#### 部署脚本

项目根目录中的 `scripts/deploy.sh` 脚本提供了部署功能：

```bash
#!/bin/bash

# 部署脚本
# 用法: ./scripts/deploy.sh [environment]
# 示例: ./scripts/deploy.sh staging

set -e

# 检查参数
if [ $# -eq 0 ]; then
    echo "Usage: $0 [environment]"
    echo "Available environments: staging, production"
    exit 1
fi

ENVIRONMENT=$1

# 检查环境是否有效
if [[ "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "production" ]]; then
    echo "Invalid environment: $ENVIRONMENT"
    echo "Available environments: staging, production"
    exit 1
fi

echo "Deploying to $ENVIRONMENT environment..."

# 构建应用
echo "Building application..."
./scripts/build.sh

# 部署前端
echo "Deploying frontend..."
case $ENVIRONMENT in
    "staging")
        # 部署到预发布环境
        echo "Deploying frontend to staging..."
        # 这里可以添加具体的部署命令，如使用 AWS CLI 上传到 S3
        # aws s3 sync frontend/dist/ s3://staging-assets.example.com/
        # 或者使用其他工具部署到静态托管服务
        ;;
    "production")
        # 部署到生产环境
        echo "Deploying frontend to production..."
        # 这里可以添加具体的部署命令，如使用 AWS CLI 上传到 S3
        # aws s3 sync frontend/dist/ s3://assets.example.com/
        # 或者使用其他工具部署到静态托管服务
        ;;
esac

# 部署后端
echo "Deploying backend..."
case $ENVIRONMENT in
    "staging")
        # 部署到预发布环境
        echo "Deploying backend to staging..."
        # 这里可以添加具体的部署命令，如使用 SSH 上传 JAR 文件并重启服务
        # ssh user@staging-server "mkdir -p /opt/certificate-management"
        # scp backend/target/*.jar user@staging-server:/opt/certificate-management/
        # ssh user@staging-server "cd /opt/certificate-management && systemctl restart certificate-management"
        ;;
    "production")
        # 部署到生产环境
        echo "Deploying backend to production..."
        # 这里可以添加具体的部署命令，如使用 SSH 上传 JAR 文件并重启服务
        # ssh user@production-server "mkdir -p /opt/certificate-management"
        # scp backend/target/*.jar user@production-server:/opt/certificate-management/
        # ssh user@production-server "cd /opt/certificate-management && systemctl restart certificate-management"
        ;;
esac

# 运行数据库迁移
echo "Running database migrations..."
case $ENVIRONMENT in
    "staging")
        # 运行预发布环境的数据库迁移
        echo "Running database migrations for staging..."
        # 这里可以添加具体的数据库迁移命令
        # ssh user@staging-database "cd /opt/certificate-management && java -jar flyway migrate"
        ;;
    "production")
        # 运行生产环境的数据库迁移
        echo "Running database migrations for production..."
        # 这里可以添加具体的数据库迁移命令
        # ssh user@production-database "cd /opt/certificate-management && java -jar flyway migrate"
        ;;
esac

echo "Deployment to $ENVIRONMENT environment completed successfully!"
```

## 环境配置

### 环境划分

项目使用多环境策略，主要包括以下环境：

1. **开发环境 (Development)**
   - 用途: 开发人员日常开发和调试
   - 特点: 完整的调试功能，频繁的代码更新
   - 访问地址: http://dev.example.com

2. **测试环境 (Testing)**
   - 用途: QA 团队测试功能和性能
   - 特点: 稳定的代码版本，模拟生产环境
   - 访问地址: http://test.example.com

3. **预发布环境 (Staging)**
   - 用途: 最终验证和用户验收测试
   - 特点: 与生产环境配置相同，但使用独立的数据
   - 访问地址: http://staging.example.com

4. **生产环境 (Production)**
   - 用途: 正式对外提供服务
   - 特点: 高可用性，高性能，严格的安全控制
   - 访问地址: https://www.example.com

### 环境配置管理

#### 前端环境配置

前端应用使用环境变量文件管理不同环境的配置：

1. `.env.development` - 开发环境配置

```bash
# 应用配置
VITE_APP_TITLE=证书生命周期管理系统 (开发)
VITE_APP_VERSION=1.0.0-dev

# API 配置
VITE_API_BASE_URL=http://dev-api.example.com/api
VITE_API_VERSION=v1

# 功能开关
VITE_ENABLE_DEBUG=true
VITE_ENABLE_MOCK=false
```

2. `.env.test` - 测试环境配置

```bash
# 应用配置
VITE_APP_TITLE=证书生命周期管理系统 (测试)
VITE_APP_VERSION=1.0.0-test

# API 配置
VITE_API_BASE_URL=http://test-api.example.com/api
VITE_API_VERSION=v1

# 功能开关
VITE_ENABLE_DEBUG=true
VITE_ENABLE_MOCK=false
```

3. `.env.staging` - 预发布环境配置

```bash
# 应用配置
VITE_APP_TITLE=证书生命周期管理系统 (预发布)
VITE_APP_VERSION=1.0.0-staging

# API 配置
VITE_API_BASE_URL=http://staging-api.example.com/api
VITE_API_VERSION=v1

# 功能开关
VITE_ENABLE_DEBUG=false
VITE_ENABLE_MOCK=false
```

4. `.env.production` - 生产环境配置

```bash
# 应用配置
VITE_APP_TITLE=证书生命周期管理系统
VITE_APP_VERSION=1.0.0

# API 配置
VITE_API_BASE_URL=https://api.example.com/api
VITE_API_VERSION=v1

# 功能开关
VITE_ENABLE_DEBUG=false
VITE_ENABLE_MOCK=false
```

#### 后端环境配置

后端应用使用 Spring Boot 的配置文件管理不同环境的配置：

1. `application.yml` - 基础配置

```yaml
server:
  port: 8080
  servlet:
    context-path: /

spring:
  application:
    name: certificate-management-backend
  profiles:
    active: dev

# 应用配置
app:
  jwt:
    expiration: 86400000 # 24小时，单位毫秒
  monitoring:
    check-interval: 3600000 # 1小时，单位毫秒
    alert-thresholds:
      - 30
      - 15
      - 7
      - 1

# 管理端点配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when-authorized
```

2. `application-dev.yml` - 开发环境配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/certificate_management_dev?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: certificate_user
    password: certificate_password
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      minimum-idle: 5
      maximum-pool-size: 15
      idle-timeout: 30000
      pool-name: CertificateHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect
  devtools:
    restart:
      enabled: true

# 日志配置
logging:
  level:
    com.example.certificate: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

# 应用配置
app:
  jwt:
    secret: dev-jwt-secret-key
```

3. `application-test.yml` - 测试环境配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://test-db.example.com:3306/certificate_management_test?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: ${DB_USER:certificate_user}
    password: ${DB_PASSWORD:certificate_password}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      minimum-idle: 5
      maximum-pool-size: 15
      idle-timeout: 30000
      pool-name: CertificateHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect

# 日志配置
logging:
  level:
    com.example.certificate: DEBUG
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
  file:
    name: logs/certificate-management-test.log

# 应用配置
app:
  jwt:
    secret: ${JWT_SECRET:test-jwt-secret-key}
```

4. `application-staging.yml` - 预发布环境配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://staging-db.example.com:3306/certificate_management_staging?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: ${DB_USER:certificate_user}
    password: ${DB_PASSWORD:certificate_password}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      minimum-idle: 10
      maximum-pool-size: 30
      idle-timeout: 60000
      pool-name: CertificateHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect

# 日志配置
logging:
  level:
    com.example.certificate: WARN
    org.springframework.web: WARN
    org.hibernate: WARN
  file:
    name: logs/certificate-management-staging.log
  logback:
    rollingpolicy:
      max-file-size: 10MB
      max-history: 30

# 应用配置
app:
  jwt:
    secret: ${JWT_SECRET:staging-jwt-secret-key}
```

5. `application-prod.yml` - 生产环境配置

```yaml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST:prod-db.example.com}:${DB_PORT:3306}/${DB_NAME:certificate_management}?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: ${DB_USER:certificate_user}
    password: ${DB_PASSWORD:certificate_password}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      minimum-idle: 10
      maximum-pool-size: 30
      idle-timeout: 60000
      pool-name: CertificateHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect

# 日志配置
logging:
  level:
    com.example.certificate: WARN
    org.springframework.web: WARN
    org.hibernate: WARN
  file:
    name: logs/certificate-management.log
  logback:
    rollingpolicy:
      max-file-size: 10MB
      max-history: 30

# 应用配置
app:
  jwt:
    secret: ${JWT_SECRET:prod-jwt-secret-key}

# 管理端点配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when-authorized
```

### 数据库配置

不同环境使用不同的数据库实例，确保数据隔离：

1. **开发环境数据库**
   - 数据库: certificate_management_dev
   - 用途: 开发人员日常开发和调试
   - 特点: 允许随意修改数据，定期重置

2. **测试环境数据库**
   - 数据库: certificate_management_test
   - 用途: QA 团队测试功能和性能
   - 特点: 包含测试数据，定期刷新

3. **预发布环境数据库**
   - 数据库: certificate_management_staging
   - 用途: 最终验证和用户验收测试
   - 特点: 包含接近生产的数据，定期从生产环境同步

4. **生产环境数据库**
   - 数据库: certificate_management
   - 用途: 正式对外提供服务
   - 特点: 高可用性，定期备份，严格的安全控制

### 环境部署流程

#### 开发环境部署

开发环境部署流程相对简单，主要面向开发人员：

1. **本地启动**
   ```bash
   # 在项目根目录执行
   npm run dev
   ```

2. **开发服务器部署**
   - 代码提交到 `develop` 分支后，CI 工作流自动构建
   - 构建成功后，自动部署到开发服务器
   - 开发人员可以通过开发环境 URL 访问应用

#### 测试环境部署

测试环境部署流程更加规范，主要面向 QA 团队：

1. **触发部署**
   - 从 `develop` 分支创建 `release/test` 分支
   - 提交到 `release/test` 分支后，CD 工作流自动构建和部署
   - 或者通过手动触发 CD 工作流部署到测试环境

2. **数据准备**
   - 部署前，准备测试数据
   - 可以使用 Flyway 运行测试数据迁移脚本

3. **验证部署**
   - QA 团队验证部署结果
   - 运行自动化测试套件
   - 记录测试结果

#### 预发布环境部署

预发布环境部署流程更加严格，接近生产环境：

1. **触发部署**
   - 从 `release/test` 分支创建 `release/staging` 分支
   - 提交到 `release/staging` 分支后，CD 工作流自动构建和部署
   - 或者通过手动触发 CD 工作流部署到预发布环境

2. **数据准备**
   - 从生产环境脱敏和抽样数据
   - 使用 Flyway 运行数据库迁移脚本
   - 验证数据完整性

3. **验证部署**
   - QA 团队和产品经理验证部署结果
   - 运行完整的功能测试和性能测试
   - 进行用户验收测试
   - 记录测试结果和问题

#### 生产环境部署

生产环境部署流程最为严格，确保系统稳定：

1. **准备部署**
   - 创建 `release/production` 分支
   - 进行最终代码审查和安全扫描
   - 准备部署计划和回滚方案
   - 通知相关人员部署时间窗口

2. **触发部署**
   - 在预定的部署时间窗口，手动触发 CD 工作流
   - 或者使用蓝绿部署、金丝雀发布等高级部署策略

3. **数据准备**
   - 备份生产数据库
   - 使用 Flyway 运行数据库迁移脚本
   - 验证数据完整性

4. **部署执行**
   - 按照部署计划执行部署步骤
   - 监控部署过程中的系统状态
   - 记录部署日志和问题

5. **验证部署**
   - 运行生产环境检查清单
   - 验证关键功能是否正常
   - 监控系统性能和错误日志
   - 收集用户反馈

6. **部署后操作**
   - 更新文档和版本号
   - 解析部署过程中的问题
   - 总结部署经验
   - 通知相关人员部署完成

### 回滚策略

为了应对部署过程中可能出现的问题，项目制定了详细的回滚策略：

#### 前端回滚

1. **版本回滚**
   - 使用 CDN 的版本控制功能回滚到上一个版本
   - 或者重新部署上一个版本的前端代码

2. **配置回滚**
   - 回滚环境变量配置
   - 禁用可能导致问题的功能开关

#### 后端回滚

1. **代码回滚**
   - 使用 Git 回滚到上一个提交
   - 重新构建和部署上一个版本

2. **数据库回滚**
   - 使用 Flyway 的回滚功能回滚数据库迁移
   - 或者从备份恢复数据库

3. **配置回滚**
   - 回滚环境变量配置
   - 回滚应用配置文件

#### 回滚流程

1. **检测问题**
   - 监控系统检测到异常
   - 用户反馈问题
   - 自动化测试失败

2. **评估影响**
   - 分析问题的严重程度和影响范围
   - 确定是否需要回滚

3. **执行回滚**
   - 按照回滚策略执行回滚操作
   - 监控回滚过程中的系统状态

4. **验证回滚**
   - 验证系统是否恢复正常
   - 运行关键功能测试
   - 收集用户反馈

5. **问题分析**
   - 分析导致问题的原因
   - 制定解决方案
   - 更新部署和测试流程

这种部署架构为证书生命周期管理系统提供了完整的部署指南，确保系统能够在不同环境中稳定运行，并支持快速、安全的部署和回滚操作。