# 安全和性能

## 概述

证书生命周期管理系统的安全和性能是确保系统稳定运行和用户数据安全的关键因素。本节详细说明了系统的安全策略、性能优化措施以及监控告警机制，确保系统在面对安全威胁和高负载情况下仍能保持稳定和高效。

## 安全策略

### 前端安全

#### 输入验证

1. **表单验证**
   - 使用 Vuelidate 进行客户端表单验证
   - 实现前端验证规则，防止无效数据提交
   - 提供友好的错误提示信息

   ```javascript
   import { required, minLength, maxLength, email } from 'vuelidate/lib/validators'

   export default {
     data() {
       return {
         form: {
           name: '',
           domain: '',
           email: ''
         }
       }
     },
     validations: {
       form: {
         name: {
           required,
           minLength: minLength(2),
           maxLength: maxLength(100)
         },
         domain: {
           required,
           minLength: minLength(3),
           maxLength: maxLength(255)
         },
         email: {
           required,
           email
         }
       }
     }
   }
   ```

2. **输入过滤**
   - 对用户输入进行过滤，移除潜在的恶意代码
   - 使用 DOMPurify 库清理用户输入
   - 防止 XSS 攻击

   ```javascript
   import DOMPurify from 'dompurify'

   export default {
     methods: {
       sanitizeInput(input) {
         return DOMPurify.sanitize(input)
       }
     }
   }
   ```

#### 身份认证

1. **JWT 认证**
   - 使用 JSON Web Token (JWT) 进行用户身份认证
   - 在登录成功后，将 JWT 存储在 localStorage 或 sessionStorage 中
   - 在后续请求中，通过 Authorization 头部发送 JWT

   ```javascript
   import axios from 'axios'

   // 设置请求拦截器
   axios.interceptors.request.use(
     config => {
       const token = localStorage.getItem('token')
       if (token) {
         config.headers.Authorization = `Bearer ${token}`
       }
       return config
     },
     error => {
       return Promise.reject(error)
     }
   )

   // 设置响应拦截器
   axios.interceptors.response.use(
     response => {
       return response
     },
     error => {
       if (error.response && error.response.status === 401) {
         // Token 过期或无效，跳转到登录页
         localStorage.removeItem('token')
         router.push('/login')
       }
       return Promise.reject(error)
     }
   )
   ```

2. **会话管理**
   - 实现 token 自动续期机制
   - 设置合理的 token 过期时间
   - 提供登出功能，清除 token

   ```javascript
   export default {
     methods: {
       logout() {
         localStorage.removeItem('token')
         localStorage.removeItem('user')
         this.$router.push('/login')
       },
       
       checkTokenExpiry() {
         const token = localStorage.getItem('token')
         if (token) {
           const decodedToken = jwtDecode(token)
           const currentTime = Date.now() / 1000
           
           // 如果 token 即将过期（例如 5 分钟内），则刷新 token
           if (decodedToken.exp - currentTime < 300) {
             this.refreshToken()
           }
         }
       },
       
       async refreshToken() {
         try {
           const response = await axios.post('/api/auth/refresh', {
             token: localStorage.getItem('token')
           })
           
           localStorage.setItem('token', response.data.token)
         } catch (error) {
           console.error('Token refresh failed:', error)
           this.logout()
         }
       }
     }
   }
   ```

#### 权限控制

1. **路由守卫**
   - 使用 Vue Router 的导航守卫控制页面访问权限
   - 根据用户角色和权限限制访问特定页面
   - 未授权用户重定向到登录页或 403 页面

   ```javascript
   import router from '@/router'
   import store from '@/stores'

   router.beforeEach(async (to, from, next) => {
     // 检查是否需要认证
     if (to.matched.some(record => record.meta.requiresAuth)) {
       // 检查用户是否已登录
       if (!store.getters.isAuthenticated) {
         // 未登录，重定向到登录页
         next({
           path: '/login',
           query: { redirect: to.fullPath }
         })
       } else {
         // 检查用户是否有权限访问该页面
         const userRoles = store.getters.userRoles
         const requiredRoles = to.meta.roles || []
         
         if (requiredRoles.length > 0 && !requiredRoles.some(role => userRoles.includes(role))) {
           // 无权限，重定向到 403 页面
           next({ path: '/403' })
         } else {
           // 有权限，继续导航
           next()
         }
       }
     } else {
       // 不需要认证，继续导航
       next()
     }
   })
   ```

2. **按钮级权限**
   - 根据用户权限动态显示或隐藏操作按钮
   - 使用 v-if 或自定义指令控制元素显示

   ```javascript
   // 自定义权限指令
   import Vue from 'vue'

   Vue.directive('permission', {
     inserted(el, binding, vnode) {
       const { value } = binding
       const roles = vnode.context.$store.getters.userRoles
       
       if (value && !roles.some(role => value.includes(role))) {
         el.parentNode && el.parentNode.removeChild(el)
       }
     }
   })
   ```

   ```html
   <!-- 使用自定义权限指令 -->
   <button v-permission="['ADMIN']">删除证书</button>
   ```

#### 安全通信

1. **HTTPS**
   - 所有通信使用 HTTPS 协议
   - 配置强加密套件
   - 启用 HSTS (HTTP Strict Transport Security)

2. **CORS 策略**
   - 配置适当的 CORS 策略，限制跨域请求
   - 在开发环境中使用代理服务器避免 CORS 问题

   ```javascript
   // vite.config.js 中的代理配置
   export default defineConfig({
     server: {
       proxy: {
         '/api': {
           target: 'http://localhost:8080',
           changeOrigin: true,
           secure: false
         }
       }
     }
   })
   ```

3. **内容安全策略 (CSP)**
   - 配置 CSP 头部，限制资源加载来源
   - 防止代码注入攻击

   ```html
   <!-- 在 index.html 中添加 CSP meta 标签 -->
   <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self'">
   ```

#### 安全最佳实践

1. **依赖管理**
   - 定期更新依赖包，修复已知安全漏洞
   - 使用 npm audit 或 yarn audit 检查依赖安全性
   - 使用 Snyk 或类似工具监控依赖安全

2. **代码安全**
   - 避免使用 eval() 和 Function() 构造函数
   - 避免使用 innerHTML，使用 textContent 或 createElement 替代
   - 使用严格模式 ('use strict')

3. **敏感信息保护**
   - 不要在前端代码中硬编码敏感信息
   - 使用环境变量管理配置
   - 敏感操作需要二次确认

### 后端安全

#### 身份认证

1. **Spring Security 配置**
   - 使用 Spring Security 提供全面的安全框架
   - 配置 JWT 认证过滤器
   - 实现用户详情服务

   ```java
   @Configuration
   @EnableWebSecurity
   @EnableGlobalMethodSecurity(prePostEnabled = true)
   public class SecurityConfig extends WebSecurityConfigurerAdapter {
       
       @Autowired
       private JwtTokenProvider jwtTokenProvider;
       
       @Autowired
       private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
       
       @Bean
       @Override
       public AuthenticationManager authenticationManagerBean() throws Exception {
           return super.authenticationManagerBean();
       }
       
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
       
       @Bean
       public JwtTokenFilter jwtTokenFilter() {
           return new JwtTokenFilter(jwtTokenProvider);
       }
       
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http
               .csrf().disable()
               .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint).and()
               .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
               .authorizeRequests()
               .antMatchers("/api/auth/**").permitAll()
               .antMatchers(HttpMethod.GET, "/api/certificates/**").hasAnyRole("USER", "ADMIN")
               .antMatchers(HttpMethod.POST, "/api/certificates/**").hasRole("ADMIN")
               .antMatchers(HttpMethod.PUT, "/api/certificates/**").hasRole("ADMIN")
               .antMatchers(HttpMethod.DELETE, "/api/certificates/**").hasRole("ADMIN")
               .antMatchers("/api/monitoring-logs/**").hasAnyRole("USER", "ADMIN")
               .antMatchers("/api/system/**").hasRole("ADMIN")
               .anyRequest().authenticated();
           
           http.addFilterBefore(jwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
       }
   }
   ```

2. **JWT 实现**
   - 实现 JWT 令牌提供者，负责生成和验证令牌
   - 实现 JWT 认证过滤器，处理请求中的 JWT
   - 实现 JWT 认证入口点，处理认证失败情况

   ```java
   @Component
   public class JwtTokenProvider {
       
       @Value("${app.jwt.secret}")
       private String jwtSecret;
       
       @Value("${app.jwt.expiration}")
       private int jwtExpirationInMs;
       
       public String generateToken(Authentication authentication) {
           UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
           
           Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationInMs);
           
           return Jwts.builder()
                   .setSubject(Long.toString(userPrincipal.getId()))
                   .setIssuedAt(new Date())
                   .setExpiration(expiryDate)
                   .signWith(SignatureAlgorithm.HS512, jwtSecret)
                   .compact();
       }
       
       public Long getUserIdFromJWT(String token) {
           Claims claims = Jwts.parser()
                   .setSigningKey(jwtSecret)
                   .parseClaimsJws(token)
                   .getBody();
           
           return Long.parseLong(claims.getSubject());
       }
       
       public boolean validateToken(String authToken) {
           try {
               Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
               return true;
           } catch (SignatureException ex) {
               logger.error("Invalid JWT signature");
           } catch (MalformedJwtException ex) {
               logger.error("Invalid JWT token");
           } catch (ExpiredJwtException ex) {
               logger.error("Expired JWT token");
           } catch (UnsupportedJwtException ex) {
               logger.error("Unsupported JWT token");
           } catch (IllegalArgumentException ex) {
               logger.error("JWT claims string is empty");
           }
           return false;
       }
   }
   ```

   ```java
   public class JwtTokenFilter extends OncePerRequestFilter {
       
       @Autowired
       private JwtTokenProvider jwtTokenProvider;
       
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) 
               throws ServletException, IOException {
           
           try {
               String jwt = getJwtFromRequest(request);
               
               if (StringUtils.hasText(jwt) && jwtTokenProvider.validateToken(jwt)) {
                   Long userId = jwtTokenProvider.getUserIdFromJWT(jwt);
                   
                   UsernamePasswordAuthenticationToken authentication = 
                           new UsernamePasswordAuthenticationToken(userId, null, null);
                   authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                   
                   SecurityContextHolder.getContext().setAuthentication(authentication);
               }
           } catch (Exception ex) {
               logger.error("Could not set user authentication in security context", ex);
           }
           
           filterChain.doFilter(request, response);
       }
       
       private String getJwtFromRequest(HttpServletRequest request) {
           String bearerToken = request.getHeader("Authorization");
           if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
               return bearerToken.substring(7);
           }
           return null;
       }
   }
   ```

#### 授权控制

1. **基于角色的访问控制**
   - 使用 Spring Security 的 @PreAuthorize 注解控制方法访问权限
   - 定义用户角色和权限
   - 实现自定义权限评估器

   ```java
   @RestController
   @RequestMapping("/api/certificates")
   public class CertificateController {
       
       @Autowired
       private CertificateService certificateService;
       
       @GetMapping
       @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
       public ResponseEntity<PageResult<CertificateVo>> getCertificates(
               @RequestParam(defaultValue = "0") int page,
               @RequestParam(defaultValue = "20") int size,
               @RequestParam(defaultValue = "id,asc") String[] sort) {
           // 实现逻辑
       }
       
       @GetMapping("/{id}")
       @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
       public ResponseEntity<CertificateVo> getCertificateById(@PathVariable Long id) {
           // 实现逻辑
       }
       
       @PostMapping
       @PreAuthorize("hasRole('ADMIN')")
       public ResponseEntity<CertificateVo> createCertificate(@Valid @RequestBody CertificateCreateDto certificateDto) {
           // 实现逻辑
       }
       
       @PutMapping("/{id}")
       @PreAuthorize("hasRole('ADMIN')")
       public ResponseEntity<CertificateVo> updateCertificate(
               @PathVariable Long id, 
               @Valid @RequestBody CertificateUpdateDto certificateDto) {
           // 实现逻辑
       }
       
       @DeleteMapping("/{id}")
       @PreAuthorize("hasRole('ADMIN')")
       public ResponseEntity<Void> deleteCertificate(@PathVariable Long id) {
           // 实现逻辑
       }
   }
   ```

2. **方法级安全**
   - 使用 @Secured、@RolesAllowed 或 @PreAuthorize 注解
   - 实现自定义权限注解

   ```java
   @Target({ElementType.METHOD, ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @PreAuthorize("hasRole('ADMIN')")
   public @interface IsAdmin {
   }
   
   @Target({ElementType.METHOD, ElementType.TYPE})
   @Retention(RetentionPolicy.RUNTIME)
   @PreAuthorize("hasAnyRole('ADMIN', 'USER')")
   public @interface IsUser {
   }
   
   @Service
   public class CertificateServiceImpl implements CertificateService {
       
       @Override
       @IsUser
       public Certificate findById(Long id) {
           // 实现逻辑
       }
       
       @Override
       @IsAdmin
       public Certificate create(Certificate certificate) {
           // 实现逻辑
       }
   }
   ```

#### 数据安全

1. **密码加密**
   - 使用 BCryptPasswordEncoder 加密存储用户密码
   - 实现密码强度验证
   - 支持密码重置功能

   ```java
   @Service
   public class UserServiceImpl implements UserService {
       
       @Autowired
       private PasswordEncoder passwordEncoder;
       
       @Autowired
       private UserRepository userRepository;
       
       @Override
       public User createUser(UserDto userDto) {
           // 验证密码强度
           if (!isPasswordStrong(userDto.getPassword())) {
               throw new ValidationException("Password does not meet strength requirements");
           }
           
           User user = new User();
           user.setUsername(userDto.getUsername());
           user.setPassword(passwordEncoder.encode(userDto.getPassword()));
           user.setEmail(userDto.getEmail());
           user.setRoles(Collections.singleton(Role.ROLE_USER));
           
           return userRepository.save(user);
       }
       
       private boolean isPasswordStrong(String password) {
           // 密码强度验证逻辑
           // 至少8个字符，包含大小写字母、数字和特殊字符
           String passwordRegex = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!])(?=\\S+$).{8,}$";
           return password.matches(passwordRegex);
       }
   }
   ```

2. **敏感数据加密**
   - 对数据库中的敏感数据进行加密存储
   - 使用 Java Cryptography Architecture (JCA) 进行加密
   - 实现数据脱敏功能

   ```java
   @Component
   public class DataEncryptionUtil {
       
       @Value("${app.encryption.key}")
       private String encryptionKey;
       
       private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
       private static final String SECRET_KEY_ALGORITHM = "AES";
       
       public String encrypt(String data) {
           try {
               SecretKeySpec secretKey = new SecretKeySpec(encryptionKey.getBytes(), SECRET_KEY_ALGORITHM);
               Cipher cipher = Cipher.getInstance(ALGORITHM);
               
               // 生成随机 IV
               byte[] iv = new byte[16];
               new SecureRandom().nextBytes(iv);
               IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
               
               cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
               byte[] encryptedData = cipher.doFinal(data.getBytes());
               
               // 组合 IV 和加密数据
               byte[] combined = new byte[iv.length + encryptedData.length];
               System.arraycopy(iv, 0, combined, 0, iv.length);
               System.arraycopy(encryptedData, 0, combined, iv.length, encryptedData.length);
               
               return Base64.getEncoder().encodeToString(combined);
           } catch (Exception e) {
               throw new RuntimeException("Encryption failed", e);
           }
       }
       
       public String decrypt(String encryptedData) {
           try {
               SecretKeySpec secretKey = new SecretKeySpec(encryptionKey.getBytes(), SECRET_KEY_ALGORITHM);
               Cipher cipher = Cipher.getInstance(ALGORITHM);
               
               // 解码 Base64 数据
               byte[] combined = Base64.getDecoder().decode(encryptedData);
               
               // 提取 IV 和加密数据
               byte[] iv = new byte[16];
               byte[] data = new byte[combined.length - 16];
               System.arraycopy(combined, 0, iv, 0, 16);
               System.arraycopy(combined, 16, data, 0, data.length);
               
               IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
               cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);
               
               byte[] decryptedData = cipher.doFinal(data);
               return new String(decryptedData);
           } catch (Exception e) {
               throw new RuntimeException("Decryption failed", e);
           }
       }
   }
   ```

3. **SQL 注入防护**
   - 使用参数化查询，避免 SQL 注入攻击
   - 使用 MyBatis Plus 提供的安全查询方法
   - 实现自定义 SQL 注入检测

   ```java
   @Service
   public class CertificateServiceImpl implements CertificateService {
       
       @Autowired
       private CertificateRepository certificateRepository;
       
       @Override
       public List<Certificate> findByDomain(String domain) {
           // 使用 MyBatis Plus 提供的安全查询方法
           return certificateRepository.findByDomain(domain);
       }
       
       @Override
       public List<Certificate> findByExpiryDateBefore(Date date) {
           // 使用 QueryWrapper 构建安全查询
           QueryWrapper<Certificate> queryWrapper = new QueryWrapper<>();
           queryWrapper.lt("expiry_date", date);
           return certificateRepository.selectList(queryWrapper);
       }
   }
   ```

#### API 安全

1. **输入验证**
   - 使用 Spring Validation 进行输入验证
   - 实现自定义验证注解
   - 提供友好的错误响应

   ```java
   @RestController
   @RequestMapping("/api/certificates")
   public class CertificateController {
       
       @PostMapping
       @PreAuthorize("hasRole('ADMIN')")
       public ResponseEntity<?> createCertificate(
               @Valid @RequestBody CertificateCreateDto certificateDto,
               BindingResult bindingResult) {
           
           if (bindingResult.hasErrors()) {
               // 收集验证错误
               List<String> errors = bindingResult.getAllErrors()
                       .stream()
                       .map(DefaultMessageSourceResolvable::getDefaultMessage)
                       .collect(Collectors.toList());
               
               ApiResponse<?> response = new ApiResponse<>(
                       false,
                       "Validation failed",
                       errors
               );
               
               return ResponseEntity.badRequest().body(response);
           }
           
           // 处理业务逻辑
           CertificateVo certificateVo = certificateService.createCertificate(certificateDto);
           
           ApiResponse<CertificateVo> response = new ApiResponse<>(
                   true,
                   "Certificate created successfully",
                   certificateVo
           );
           
           return ResponseEntity.ok(response);
       }
   }
   ```

2. **输出过滤**
   - 使用 DTO 和 VO 控制输出数据
   - 实现数据脱敏，隐藏敏感信息
   - 使用 Jackson 注解控制 JSON 序列化

   ```java
   @Data
   public class UserVo {
       private Long id;
       private String username;
       private String email;
       
       @JsonIgnore
       private String password;
       
       @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
       private String secretKey;
       
       @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
       private Date createdAt;
   }
   ```

3. **速率限制**
   - 实现 API 速率限制，防止滥用和攻击
   - 使用 Spring Boot Starter for Redis 实现分布式速率限制
   - 提供友好的错误响应

   ```java
   @Configuration
   @EnableRedisHttpSession
   public class RateLimitConfig {
       
       @Bean
       public FilterRegistrationBean<RateLimitFilter> rateLimitFilterRegistrationBean() {
           FilterRegistrationBean<RateLimitFilter> registration = new FilterRegistrationBean<>();
           registration.setFilter(new RateLimitFilter());
           registration.addUrlPatterns("/api/*");
           registration.setName("rateLimitFilter");
           registration.setOrder(1);
           return registration;
       }
   }
   
   public class RateLimitFilter extends OncePerRequestFilter {
       
       @Autowired
       private RedisTemplate<String, Object> redisTemplate;
       
       @Value("${app.rate.limit.requests}")
       private int rateLimitRequests;
       
       @Value("${app.rate.limit.window}")
       private int rateLimitWindow;
       
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) 
               throws ServletException, IOException {
           
           String clientId = getClientId(request);
           String key = "rate_limit:" + clientId;
           
           // 使用 Redis 的 INCR 和 EXPIRE 实现速率限制
           Long current = redisTemplate.opsForValue().increment(key);
           
           if (current != null && current == 1) {
               redisTemplate.expire(key, rateLimitWindow, TimeUnit.SECONDS);
           }
           
           if (current != null && current > rateLimitRequests) {
               response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
               response.getWriter().write("Rate limit exceeded");
               return;
           }
           
           filterChain.doFilter(request, response);
       }
       
       private String getClientId(HttpServletRequest request) {
           // 可以使用 IP 地址、用户 ID 或 API 密钥作为客户端 ID
           String ipAddress = request.getRemoteAddr();
           String userAgent = request.getHeader("User-Agent");
           
           // 如果用户已认证，使用用户 ID
           Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
           if (authentication != null && authentication.isAuthenticated() 
                   && !"anonymousUser".equals(authentication.getPrincipal())) {
               return authentication.getName();
           }
           
           // 否则使用 IP 地址和用户代理的组合
           return DigestUtils.md5Hex(ipAddress + userAgent);
       }
   }
   ```

#### 安全最佳实践

1. **依赖管理**
   - 定期更新依赖，修复已知安全漏洞
   - 使用 OWASP Dependency Check 检查依赖安全性
   - 避免使用已知有安全问题的库

2. **日志安全**
   - 记录安全相关事件，如登录失败、权限拒绝等
   - 不要在日志中记录敏感信息，如密码、令牌等
