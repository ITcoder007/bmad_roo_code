# Monitoring and Observability

## Monitoring Stack

- **Frontend Monitoring**: Vue.js 应用使用 Sentry 进行错误跟踪和性能监控
- **Backend Monitoring**: Spring Boot 应用使用 Micrometer + Prometheus 指标收集
- **Error Tracking**: Sentry 集成前后端错误跟踪，统一错误管理
- **Performance Monitoring**: 前端使用 Web Vitals，后端使用 Prometheus + Grafana

## Key Metrics

### Frontend Metrics

- **Core Web Vitals**
  - LCP (Largest Contentful Paint): < 2.5s
  - FID (First Input Delay): < 100ms
  - CLS (Cumulative Layout Shift): < 0.1
- **JavaScript errors**: 错误率和错误类型分布
- **API response times**: 95% 请求 < 1s
- **User interactions**: 用户操作成功率和响应时间
- **Certificate operations**: 证书管理操作的成功率和耗时

### Backend Metrics

- **Request rate**: 每秒请求数 (RPS)
- **Error rate**: HTTP 错误率 (4xx, 5xx)
- **Response time**: API 响应时间分布 (P50, P95, P99)
- **Database query performance**: 查询执行时间和慢查询数量
- **Certificate monitoring metrics**:
  - 证书检查成功率
  - 证书状态分布（有效、即将过期、已过期）
  - 证书预警触发次数
  - 证书操作成功率

## Implementation Details

### Frontend Monitoring Setup

```typescript
// src/utils/monitoring.ts
import * as Sentry from '@sentry/vue';
import { BrowserTracing } from '@sentry/tracing';
import { Integrations } from '@sentry/tracing';
import { onCLS, onFID, onLCP } from 'web-vitals';

export class MonitoringService {
  private static instance: MonitoringService;
  
  static getInstance(): MonitoringService {
    if (!MonitoringService.instance) {
      MonitoringService.instance = new MonitoringService();
    }
    return MonitoringService.instance;
  }
  
  init(app: any, router: any): void {
    // 初始化 Sentry
    Sentry.init({
      app,
      dsn: process.env.VUE_APP_SENTRY_DSN,
      integrations: [
        new BrowserTracing({
          routingInstrumentation: Sentry.vueRouterInstrumentation(router),
        }),
      ],
      tracesSampleRate: 1.0,
      environment: process.env.NODE_ENV,
      release: `certificate-manager@${process.env.VUE_APP_VERSION}`,
    });
    
    // 初始化 Web Vitals 监控
    this.initWebVitals();
    
    // 监控未捕获的 Promise 错误
    window.addEventListener('unhandledrejection', this.handleUnhandledRejection);
    
    // 监控全局错误
    window.addEventListener('error', this.handleGlobalError);
  }
  
  private initWebVitals(): void {
    // 监控 Core Web Vitals
    onCLS((metric) => {
      this.sendMetricToAnalytics('CLS', metric.value);
      Sentry.addBreadcrumb({
        message: `CLS: ${metric.value}`,
        level: 'info',
        category: 'performance',
      });
    });
    
    onFID((metric) => {
      this.sendMetricToAnalytics('FID', metric.value);
      Sentry.addBreadcrumb({
        message: `FID: ${metric.value}`,
        level: 'info',
        category: 'performance',
      });
    });
    
    onLCP((metric) => {
      this.sendMetricToAnalytics('LCP', metric.value);
      Sentry.addBreadcrumb({
        message: `LCP: ${metric.value}`,
        level: 'info',
        category: 'performance',
      });
    });
  }
  
  private handleUnhandledRejection = (event: PromiseRejectionEvent): void => {
    Sentry.captureException(event.reason);
    this.sendErrorToAnalytics('UnhandledPromiseRejection', event.reason);
  };
  
  private handleGlobalError = (event: ErrorEvent): void => {
    Sentry.captureException(event.error);
    this.sendErrorToAnalytics('GlobalError', event.error);
  };
  
  // 监控证书操作
  trackCertificateOperation(operation: string, duration: number, success: boolean): void {
    const metricName = `certificate_operation_${operation}`;
    this.sendMetricToAnalytics(metricName, duration, {
      success: success.toString(),
    });
    
    Sentry.addBreadcrumb({
      message: `Certificate ${operation}: ${success ? 'success' : 'failed'} (${duration}ms)`,
      level: success ? 'info' : 'warning',
      category: 'certificate',
      data: { duration, operation },
    });
  }
  
  // 监控 API 调用
  trackApiCall(endpoint: string, method: string, duration: number, statusCode: number): void {
    const metricName = `api_call_${method.toLowerCase()}_${endpoint.replace(/\//g, '_')}`;
    this.sendMetricToAnalytics(metricName, duration, {
      status_code: statusCode.toString(),
    });
    
    if (statusCode >= 400) {
      Sentry.addBreadcrumb({
        message: `API Error: ${method} ${endpoint} - ${statusCode}`,
        level: 'warning',
        category: 'api',
        data: { duration, statusCode },
      });
    }
  }
  
  private sendMetricToAnalytics(name: string, value: number, tags?: Record<string, string>): void {
    // 发送指标到分析系统
    // 这里可以根据实际使用的分析系统实现
    console.log(`Metric: ${name} = ${value}`, tags);
  }
  
  private sendErrorToAnalytics(type: string, error: any): void {
    // 发送错误到分析系统
    console.error(`Error (${type}):`, error);
  }
}

// 在 main.ts 中初始化监控
// import { MonitoringService } from './utils/monitoring';
// const monitoring = MonitoringService.getInstance();
// monitoring.init(app, router);
```

### Backend Monitoring Setup

```java
// src/main/java/com/certmanager/config/MonitoringConfig.java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MonitoringConfig implements WebMvcConfigurer {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags(
            "application", "certificate-manager",
            "region", System.getenv().getOrDefault("REGION", "default")
        );
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new ApiMetricsInterceptor());
    }
}

// src/main/java/com/certmanager/interceptor/ApiMetricsInterceptor.java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class ApiMetricsInterceptor implements HandlerInterceptor {
    
    private final MeterRegistry meterRegistry;
    private final ThreadLocal<Long> startTime = new ThreadLocal<>();
    
    public ApiMetricsInterceptor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        startTime.set(System.currentTimeMillis());
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
            Object handler, Exception ex) {
        
        long duration = System.currentTimeMillis() - startTime.get();
        String endpoint = request.getRequestURI();
        String method = request.getMethod();
        int statusCode = response.getStatus();
        
        // 记录 API 调用时间
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("api.request.duration")
            .tag("endpoint", endpoint)
            .tag("method", method)
            .tag("status", String.valueOf(statusCode))
            .register(meterRegistry));
        
        // 记录请求计数
        meterRegistry.counter("api.request.count", 
            "endpoint", endpoint,
            "method", method,
            "status", String.valueOf(statusCode))
            .increment();
        
        startTime.remove();
    }
}

// src/main/java/com/certmanager/service/CertificateMonitoringService.java
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Service;
import java.util.concurrent.atomic.AtomicInteger;

@Service
public class CertificateMonitoringService {
    
    private final MeterRegistry meterRegistry;
    private final AtomicInteger totalCertificates = new AtomicInteger(0);
    private final AtomicInteger expiredCertificates = new AtomicInteger(0);
    private final AtomicInteger expiringCertificates = new AtomicInteger(0);
    
    public CertificateMonitoringService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 注册证书相关指标
        meterRegistry.gauge("certificate.total", totalCertificates);
        meterRegistry.gauge("certificate.expired", expiredCertificates);
        meterRegistry.gauge("certificate.expiring", expiringCertificates);
    }
    
    public void recordCertificateCheck(boolean success, long duration) {
        meterRegistry.counter("certificate.check.count", "success", String.valueOf(success))
            .increment();
        
        meterRegistry.timer("certificate.check.duration")
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    public void recordCertificateOperation(String operation, boolean success, long duration) {
        meterRegistry.counter("certificate.operation.count", 
                "operation", operation,
                "success", String.valueOf(success))
            .increment();
        
        meterRegistry.timer("certificate.operation.duration", "operation", operation)
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    public void updateCertificateMetrics(int total, int expired, int expiring) {
        totalCertificates.set(total);
        expiredCertificates.set(expired);
        expiringCertificates.set(expiring);
    }
    
    public void recordAlertSent(String alertType) {
        meterRegistry.counter("certificate.alert.sent", "type", alertType)
            .increment();
    }
}
```

### Prometheus Configuration

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "certificate_alerts.yml"

scrape_configs:
  - job_name: 'certificate-manager-backend'
    static_configs:
      - targets: ['backend:8080']
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    
  - job_name: 'certificate-manager-frontend'
    static_configs:
      - targets: ['frontend:3000']
    metrics_path: '/metrics'
    scrape_interval: 30s
```

### Alert Rules

```yaml
# certificate_alerts.yml
groups:
  - name: certificate_manager_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(api_request_count_total{status=~"5.."}[5m]) / rate(api_request_count_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }} for the last 5 minutes"
          
      - alert: SlowResponseTime
        expr: histogram_quantile(0.95, rate(api_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Slow response time detected"
          description: "95th percentile response time is {{ $value }} seconds"
          
      - alert: ExpiredCertificates
        expr: certificate_expired > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Expired certificates detected"
          description: "There are {{ $value }} expired certificates"
          
      - alert: ExpiringCertificates
        expr: certificate_expiring > 0
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "Certificates expiring soon"
          description: "There are {{ $value }} certificates expiring within 7 days"
```

## Rationale

1. **全面监控覆盖**：监控策略覆盖了前端和后端的各个方面，包括性能指标、错误率、业务指标等，确保系统的可观测性。

2. **证书特定指标**：针对证书管理系统的特点，设计了专门的证书相关指标，如证书状态分布、证书操作成功率、证书预警触发次数等，帮助团队实时了解证书管理状况。

3. **分层监控架构**：前端使用 Sentry 和 Web Vitals，后端使用 Micrometer 和 Prometheus，形成完整的监控栈，各层监控工具针对不同层面的需求。

4. **实时告警机制**：通过 Prometheus 告警规则，对关键指标设置阈值告警，如高错误率、慢响应时间、过期证书等，确保团队能够及时响应问题。

5. **性能指标标准化**：前端采用 Core Web Vitals 标准，后端采用标准的响应时间分布指标，确保性能评估的客观性和可比性。

6. **操作可追踪性**：通过请求 ID 和分布式追踪，可以追踪一个请求从前端到后端的完整链路，便于问题定位和性能分析。

7. **业务价值导向**：监控指标不仅关注技术指标，还关注业务指标，如证书管理操作的成功率和耗时，直接反映系统的业务价值。

8. **可扩展性设计**：监控架构设计考虑了系统的扩展性，可以轻松添加新的指标和告警规则，适应系统的发展和变化。

这种监控和可观测性策略确保了证书管理系统的稳定性、可靠性和可维护性，帮助团队及时发现和解决问题，保障业务的连续性。